<html>
    <head>
        <!--
            Panoramic photo credit:
                "Heimaey, harbour entrance" - Brian Digital
                Released under Attribution-NonCommercial-ShareAlike 2.0 Generic (CC BY-NC-SA 2.0)
                (Originally found at https://www.flickr.com/photos/brian_digital/41073561590/)
        -->

        <title>threejs - panorama</title>
		<meta charset="utf-8">
        <style>
            body {
                margin: 0;
                overflow: hidden;
                background: black;
            }
            canvas {
                background: black;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas"></canvas>

        <script src="../../lib/three.js"></script>

        <script>
            // https://github.com/mrdoob/three.js/blob/master/examples/webgl_panorama_equirectangular.html


            let texture_placeholder,
			isUserInteracting = false,
			onMouseDownMouseX = 0, onMouseDownMouseY = 0,
			lon = 0, onMouseDownLon = 0,
			lat = 0, onMouseDownLat = 0,
			phi = 0, theta = 0,
			distance = 50,
			onPointerDownPointerX = 0,
			onPointerDownPointerY = 0,
			onPointerDownLon = 0,
            onPointerDownLat = 0;
            
            let scene, camera, renderer;
            
            function initRenderer() {
                renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('myCanvas'), antialias: true });
                renderer.setClearColor(0x000000);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function initCamera() {
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
                camera.target = new THREE.Vector3( 0, 0, 0 );
            }

            function initScene() {
                scene = new THREE.Scene();

                // Sky
                var geometry = new THREE.SphereBufferGeometry( 500, 60, 40 );
				geometry.scale( - 1, 1, 1 );
				var material = new THREE.MeshBasicMaterial( {
					map: new THREE.TextureLoader().load( '../../resources/textures/41073561590_e6518def27_k.jpg' )
				} );
				mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );
            }

            function render() {
                requestAnimationFrame(render);
                update();
                renderer.render(scene, camera);
            }

            initRenderer();
            initCamera();
            initScene();
            
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'mouseup', onDocumentMouseUp, false );
            document.addEventListener( 'wheel', onDocumentMouseWheel, false );

            window.addEventListener( 'resize', onWindowResize, false );

            render();

            function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
            }
            function onDocumentMouseDown( event ) {
				event.preventDefault();
				isUserInteracting = true;
				onPointerDownPointerX = event.clientX;
				onPointerDownPointerY = event.clientY;
				onPointerDownLon = lon;
				onPointerDownLat = lat;
			}
			function onDocumentMouseMove( event ) {
				if ( isUserInteracting === true ) {
					lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
					lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
				}
			}
			function onDocumentMouseUp( event ) {
				isUserInteracting = false;
			}
			function onDocumentMouseWheel( event ) {
				distance += event.deltaY * 0.05;
				distance = THREE.Math.clamp( distance, 1, 50 );
			}
			function update() {
				lat = Math.max( - 85, Math.min( 85, lat ) );
				phi = THREE.Math.degToRad( 90 - lat );
				theta = THREE.Math.degToRad( lon );
				camera.position.x = distance * Math.sin( phi ) * Math.cos( theta );
				camera.position.y = distance * Math.cos( phi );
				camera.position.z = distance * Math.sin( phi ) * Math.sin( theta );
				camera.lookAt( camera.target );
				renderer.render( scene, camera );
			}

        </script>
    </body>
</html> 